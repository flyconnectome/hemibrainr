############################################################################
################################ Synapses ##################################
############################################################################

#' Extract synapse location and labels, and edgelists from a neuron/neuronlist
#'
#' @description Extract a single data frame describing synapse/connection types,
#'   partners, locations and position on a neuron's axon/dendrite. You can
#'   either get all synapses returned or all unitary connections to a neuron's
#'   partners returned. Broken down by axon/dendrite (\code{Label}), and
#'   pre/postsynapses or pre/postsynaptic partners. Note that \code{hemibrain_extract_compartment_edgelist} will
#'   only return connections between neurons given in the argument \code{x}.
#'
#' @inheritParams flow_centrality
#'
#' @param prepost whether to get presynapses, postsynapses or both
#' @param meta a data frame giving neuron metrics (i.e. as generated by \code{hemibrain_compartment_metrics}) and transmitter predictions (column \code{top.nt}) for the neurons supplied to these functions.
#'
#' @return a \code{data.frame}. Depending on which synapse function was called, it can contain the columns:
#'
#' \itemize{
#'
#'   \item{"treenode_id"} { - the position of the node in the SWC-style table found at \code{neuron$d}, where the neuron is the skeleton for \code{bodyid}.}
#'
#'   \item{"connector_id"}{ - the unique ID for a pre/post synapse, as read from neuPrint. If this is not given, you are looking at a connection not a synapse.
#'   In this case \code{count} should be given, which shows the number of synapses in this connection.}
#'
#'   \item{"prepost"}{ - whether the given synapse is a pre-synapse (0, output synapse) or postsynapse (1, input synapse). Alternatively, if a connection is given,
#'   whether this connection is presynaptic to \code{bodyid} (0, \code{bodyid} is target) or postsynaptic (1, \code{bodyid} is source).}
#'
#'   \item{"x"}{ - x coordinate for the root point.}
#'
#'   \item{"y"}{ - y coordinate for the root point.}
#'
#'   \item{"z"}{ - z coordinate for the root point.}
#'
#'   \item{"confidence"}{ - FlyEM's confidence level. The lower the score, the more likely this synapse is an artefact.}
#'
#'   \item{"bodyid"}{ - The neuPrint neuron/body related to the synapse/connection given in each row.}
#'
#'   \item{"partner"}{ - The neuron connecting to \code{bodyid} by the given synapse/connection.}
#'
#'   \item{"pre"}{ - The body ID for the presynaptic (source) neuron.}
#'
#'   \item{"partner"}{ - The body ID for the presynaptic (target) neuron.}
#'
#'   \item{"Label"}{ - The compartment of the \code{bodyid} neuron on which the synapse is placed / which receives/makes the given connection.
#'   See \code{?standardise}.}
#'
#'   \item{"partner_Label"}{ - The compartment of the \code{partner} neuron on which the synapse is placed / which receives/makes the given connection.}
#'
#'   \item{"count"}{ - The number of synapses that make the given connection. Sometimes referred to as 'weight'.}
#'
#'   \item{"norm"}{ - The normalised synapse weight. \code{count} is divided by the total number of inputs that the
#'   target neuron's (\code{post}) compartment (\code{Label}) has. I.e. this normalisation is by total inputs onto a dendrite or axon, not the whole neuron.}
#'
#'   \item{"connection"}{ - The type of compartment-compartment connection specified by this row. The first compartment is the source (pre), the second, the target (post).}
#'
#'}
#'
#' @export
#' @rdname hemibrain_extract_connections
#' @seealso \code{\link{flow_centrality}}
#' @importFrom nat nlapply is.neuron is.neuronlist
#' @examples
#' \dontrun{
#' # Choose bodyids
#' some.pns  = sample(pn.ids, 20)
#'
#' # Read in these neurons
#' neurons = neuprintr::neuprint_read_neurons(some.pns)
#'
#' # Re-root
#' neurons.flow = flow_centrality(neurons,
#' polypre = TRUE,
#' mode = "centrifugal", split = "distance")
#'
#' # Let's check that this worked
#' syns = hemibrain_extract_synapses(neurons.flow)
#'
#' # Get the edgelist by compartment
#' elist = hemibrain_extract_compartment_edgelist(neurons.flow)
#'
#' # See result
#' library(nat)
#' plot3d_split(neuron.flow)
#' points3d(xyzmatrix(subset(syns,prepost==1)), col = "cyan")
#' points3d(xyzmatrix(subset(syns,prepost==0)), col = "red")
#' }
hemibrain_extract_synapses <- function(x,
                                       prepost = c("BOTH","PRE","POST"),
                                       ...){
  prepost = match.arg(prepost)
  if(nat::is.neuronlist(x)){
    if(!is.null(names(x))){
      x = add_field_seq(x,names(x),field="id")
    }else if("bodyid"%in%colnames(x[,])){
      x = add_field_seq(x,x[,"bodyid"],field="bodyid")
    }else if("skid"%in%colnames(x[,])){
      x = add_field_seq(x,x[,"skid"],field="skid")
    }else if("flywire.id"%in%colnames(x[,])){
      x = add_field_seq(x,x[,"flywire.id"],field="flywire.id")
    }
    syns = nat::nlapply(x,extract_synapses, unitary = FALSE, ...)
    syns = do.call(rbind,syns)
  }else if (nat::is.neuron(x)){
    syns = extract_synapses(x, unitary = FALSE)
  }else if(is.data.frame(x) && "prepost"%in%colnames(x)){
    syns = extract_synapses(x, unitary = FALSE)
  }else{
    stop("x must be a neuron or neuronlist object")
  }
  if(prepost=="PRE"){
    syns = syns[syns$prepost==0,]
  }else if (prepost=="POST"){
    syns = syns[syns$prepost==1,]
  }
  if(!is.null(syns)){
    rownames(syns) = 1:nrow(syns)
  }
  syns
}

#' @export
#' @rdname hemibrain_extract_connections
hemibrain_extract_connections <- function(x,
                                       prepost = c("BOTH","PRE","POST"),
                                       meta = NULL,
                                       ...){
  prepost = match.arg(prepost)
  if(nat::is.neuronlist(x)){
    if(!is.null(names(x))){
      x = add_field_seq(x,names(x),field="id")
    }else if("bodyid"%in%colnames(x[,])){
      x = add_field_seq(x,x[,"bodyid"],field="bodyid")
    }else if("skid"%in%colnames(x[,])){
      x = add_field_seq(x,x[,"skid"],field="skid")
    }else if("flywire.id"%in%colnames(x[,])){
      x = add_field_seq(x,x[,"flywire.id"],field="flywire.id")
    }
    x = add_field_seq(x,names(x),field=id)
    syns = nat::nlapply(x, extract_synapses, unitary = TRUE, meta = meta, ...)
    syns = do.call(rbind,syns)
  }else if (nat::is.neuron(x)){
    syns = extract_synapses(x, unitary = TRUE)
  }else if(is.data.frame(x) && "prepost"%in%colnames(x)){
    syns = extract_synapses(x, unitary = TRUE)
  }else{
    stop("x must be a neuron or neuronlist object")
  }
  if(prepost=="PRE"){
    syns = syns[syns$prepost==0,]
  }else if (prepost=="POST"){
    syns = syns[syns$prepost==1,]
  }
  if(length(syns)){
    syns$Label = standard_compartments(syns$Label)
    rownames(syns) = 1:nrow(syns)
    syns = syns[order(syns$count, decreasing = TRUE),]
  }
  syns
}

#' @importFrom magrittr %>%
#' @export
magrittr::`%>%`
# hidden
#' @importFrom dplyr filter mutate group_by distinct select n case_when
#' @importFrom rlang .data
extract_synapses <-function(x, unitary = FALSE, meta = NULL){
  if(nat::is.neuron(x)){
    syn = x$connectors
  }else{
    syn = x
  }
  if(!is.null(x$flywire.id)){
    id = "flywire.id"
  } else if(!is.null(x$skid)){
    id = "skid"
  } else if(!is.null(x$bodyid)){
      id = "bodyid"
  }else{
    id = "id"
  }
  if(!nrow(syn)){
    warning("Neuron ", x$id," has no synapses")
  }
  syn[[id]] = nullToNA(as.character(x[[id]]))
  syn[[id]] = gsub(" ","",syn[[id]])
  if(is.null(syn$Label)){
    syn$Label = nullToNA(x$d$Label[match(syn$treenode_id,x$d$PointNo)])
  }
  poss.nts=c("gaba", "acetylcholine", "glutamate", "octopamine", "serotonin", "dopamine")
  if(!all(c(poss.nts,"top.nt")%in%colnames(syn))){
    for(pnt in setdiff(poss.nts,colnames(syn))){
      syn[[pnt]] = 0
    }
    syn$top.nt = "unknown"
  }
  poss.nts = intersect(poss.nts, colnames(syn))
  if(!is.null(meta)){
    if(!is.null(syn$top.nt)){
      syn$syn.top.nt = syn$top.nt
      syn$top.nt = NULL
    }
    if(all(c(id,"top.nt")%in%colnames(meta))){
      meta$pre_id  = meta[[id]]
      if(bit64::is.integer64(syn$pre_id)){
        meta$pre_id = bit64::as.integer64(meta$pre_id)
      }else if(is.character(syn$pre_id)){
        meta$pre_id = as.character(meta$pre_id)
      }
      syn = dplyr::inner_join(syn, meta[,c("pre_id","top.nt")],
                              by = "pre_id",
                              copy = TRUE,
                              auto_index = TRUE)
    }else{
      warning("top.nt must not in colnames(meta)")
    }
  }else if(length(poss.nts) && syn$top.nt != "unknown"){
    if(sum(syn[,colnames(syn)%in%poss.nts],na.rm = TRUE)==0){
      syn$top.nt = "unknown"
    }else{
      zeros=apply(syn[,colnames(syn)%in%poss.nts], 1, function(x) sum(x,na.rm=TRUE)==0)
      syn$top.nt = apply(syn[,colnames(syn)%in%poss.nts], 1, function(x) names(x)[which.max(x)])
      syn$top.nt[zeros] = "unknown"
    }
    warning("top.nt may be taken on a per synapse, rather than per neuron, basis")
  }else{
    syn$top.nt = "unknown"
  }
  if(unitary){ # connections, rather than synapses
    if(id == "flywire.id"){
      syn %>%
        dplyr::mutate(partner = dplyr::case_when(
          .data$prepost==0 ~ .data$post_id,
          .data$prepost==1  ~ .data$pre_id
        )) %>%
        dplyr::mutate(prepost = dplyr::case_when(
          .data$prepost==0 ~ 1,
          .data$prepost==1  ~ 0
        )) %>% # i.e. switch perspective, presynapses connect to postsynaptic partners
        dplyr::group_by(.data[[id]], .data$partner, .data$prepost, .data$Label) %>%
        dplyr::mutate(count = dplyr::n()) %>%
        dplyr::distinct(.data[[id]], .data$partner, .data$prepost, .data$Label, .data$count, .data$top.nt, .keep_all = FALSE) %>%
        as.data.frame(stringsAsFactors = FALSE) ->
        syn
    }else{
      syn %>%
        dplyr::mutate(prepost = dplyr::case_when(
          .data$prepost==0 ~ 1,
          .data$prepost==1  ~ 0
        )) %>% # i.e. switch perspective, presynapses connect to postsynaptic partners
        dplyr::group_by(.data[[id]], .data$partner, .data$prepost, .data$Label) %>%
        dplyr::mutate(count = dplyr::n()) %>%
        dplyr::distinct(.data[[id]], .data$partner, .data$prepost, .data$Label, .data$count, .data$top.nt, .keep_all = FALSE) %>%
        as.data.frame(stringsAsFactors = FALSE) ->
        syn
    }
  }
  syn$Label = standard_compartments(syn$Label)
  syn
}

#' @export
#' @rdname hemibrain_extract_connections
hemibrain_extract_compartment_edgelist <- function(x, meta = NULL, ...){
  if(nat::is.neuronlist(x)){
    x = add_field_seq(x,names(x),field="bodyid")
    y = x[[1]]
    if(!is.null(y$flywire.id)){
      id = "flywire.id"
      partner = "post_id"
    } else if(!is.null(y$skid)){
      id = "skid"
      partner = "partner"
    } else if(!is.null(y$bodyid)){
      id = "bodyid"
      partner = "partner"
    }else{
      id = "id"
      partner = "partner"
    }
    syns.list = nat::nlapply(x, extract_synapses, unitary = FALSE, meta = meta, ...)
  }else{
    syns.list = x
    warning("x should be a neuronlist object")
  }
  names(syns.list) = NULL
  lookup = nat::nlapply(syns.list, extract_lookup,  ...)
  lookup = unlist(lookup)
  sel.cols = c("total.outputs", "total.inputs", "axon.outputs",
               "dend.outputs", "axon.inputs", "dend.inputs")
  if(sum(sel.cols%in%colnames(x[,]))!=length(sel.cols)){
    if(is.null(meta)){
      mets = hemibrain_compartment_metrics(x, OmitFailures = TRUE, delta = 5, resample = NULL, locality = FALSE)
      mets[is.na(mets)] = 0
    }else{
      mets = meta
    }
  }else{
    mets = x[,]
  }
  comp.meta = mets[,colnames(mets)%in%c("total.outputs", "total.inputs", "axon.outputs",
                   "dend.outputs", "axon.inputs", "dend.inputs","top.nt")]
  elists = nat::nlapply(syns.list, extract_elist, lookup = lookup, id = id, partner = partner, meta = comp.meta, ...)
  elist = do.call(rbind, elists)
  if(length(elist)){
    rownames(elist) = 1:nrow(elist)
    elist = elist[order(elist$norm, decreasing = TRUE),]
    elist = elist[order(elist$count, decreasing = TRUE),]
  }
  elist
}

# hidden, for one pre neuron
extract_elist <- function(syns, lookup, meta = NULL, id = "bodyid", partner = "partner"){
  ids = unique(nullToNA(as.character(syns[[id]])))
  if(!is.null(meta)){
    if(!ids%in%rownames(meta)){
      stop(ids, " not in rownames of meta")
    }
    d.post = nullToNA(as.numeric(meta[ids,"dend.inputs"]))
    a.post = nullToNA(as.numeric(meta[ids,"axon.inputs"]))
    if(is.null(meta[[id]])){
      meta[[id]]=rownames(meta)
    }
    if(is.null(meta[["top.nt"]])){
      meta[["top.nt"]]="unknown"
    }
    meta$pre_id  = meta[[id]]
    if(bit64::is.integer64(syns$pre_id)){
      meta$pre_id = bit64::as.integer64(meta$pre_id)
    }else if(is.character(syns$pre_id)){
      meta$pre_id = as.character(meta$pre_id)
    }
    syns$top.nt = NULL
    syns = dplyr::inner_join(syns, meta[,c("pre_id","top.nt")],
                            by = "pre_id",
                            copy = TRUE,
                            auto_index = TRUE)
  }else{
    d.post = nrow(subset(syns, syns$prepost==1 & syns$Label==3))
    a.post = nrow(subset(syns, syns$prepost==1 & syns$Label==2))
    syns$top.nt = "unknown"
    warning("Argument 'meta' not given. norm column represents normalisation by the total number of pre-post connections
    in the final data.frame, not necessarily the total number of postsynapses for
    the 'post' neuron.")
  }
  syns %>%
    # Re-name for clarity
    dplyr::filter(.data$prepost==0) %>%
    dplyr::rename(pre = .data[[id]]) %>%
    dplyr::rename(post = .data[[partner]]) %>%
    dplyr::rename(post_Label = .data$Label) %>%
    # Compartment labels
    dplyr::mutate(pre_Label = lookup[as.character(.data$connector_id)]) %>%
    dplyr::mutate(pre_Label = ifelse(is.na(.data$pre_Label),"error",.data$pre_Label)) %>%
    # Synapse counts
    dplyr::group_by(.data$post, .data$pre, .data$post_Label, .data$pre_Label) %>%
    dplyr::mutate(count = dplyr::n()) %>%
    # Normalised synapses, by compartment
    dplyr::ungroup() %>%
    dplyr::group_by(.data$post,.data$post_Label) %>%
    dplyr::mutate(norm = .data$count/ifelse(.data$post_Label%in%c(3,"dendrite","dendrites","dend"),d.post,a.post)) %>%
    # Clean up
    dplyr::distinct(.data$post, .data$pre,.data$post_Label, .data$pre_Label, .data$count, .data$norm, .data$top.nt, .keep_all = FALSE) %>%
    dplyr::filter(!is.na(.data$pre_Label) & .data$count > 0  & .data$pre_Label!="error") %>%
    as.data.frame(stringsAsFactors = FALSE) ->
    elist
  if(nrow(elist)){
    rownames(elist) = 1:nrow(elist)
    elist$post_Label = standard_compartments(elist$post_Label)
    elist$pre_Label = standard_compartments(elist$pre_Label)
    elist$connection = paste(elist$pre_Label,elist$post_Labell,sep="-")
    elist[,c("pre", "post", "pre_Label", "post_Label", "count", "norm", "top.nt")]
  }else{
    NULL
  }
}

# hidden
extract_lookup <- function(syns){
  syns %>%
    dplyr::filter(.data$prepost==0) %>%
    dplyr::distinct(.data$connector_id, .data$Label, .keep_all = FALSE) %>%
    as.data.frame(stringsAsFactors = FALSE) ->
    conn.lookup
  lookup = conn.lookup$Label
  names(lookup) = as.character(conn.lookup$connector_id)
  lookup = lookup[!names(lookup)%in%c("0","NA")]
  lookup
}
